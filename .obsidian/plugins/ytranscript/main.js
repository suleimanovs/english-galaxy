/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => YTranscriptPlugin
});
module.exports = __toCommonJS(main_exports);

// buffer-polyfill.js
if (typeof Buffer === "undefined") {
  globalThis.Buffer = {
    from: function(data) {
      if (data instanceof Uint8Array) {
        let binary = "";
        for (let i = 0; i < data.length; i++) {
          binary += String.fromCharCode(data[i]);
        }
        return {
          toString: function(encoding) {
            if (encoding === "base64") {
              return btoa(binary);
            }
            return binary;
          }
        };
      }
      return {
        toString: function(encoding) {
          if (encoding === "base64") {
            return btoa(String(data));
          }
          return String(data);
        }
      };
    }
  };
}

// src/main.ts
var import_obsidian4 = require("obsidian");

// src/transcript-view.ts
var import_obsidian2 = require("obsidian");

// src/youtube-transcript.ts
var import_obsidian = require("obsidian");

// src/types.ts
var YoutubeTranscriptError = class extends Error {
  constructor(err) {
    if (!(err instanceof Error)) {
      super("");
      return;
    }
    if (err.message.includes("ERR_INVALID_URL")) {
      super("Invalid YouTube URL");
    } else {
      super(err.message);
    }
  }
};

// src/api-parser.ts
var YOUTUBE_TITLE_REGEX = new RegExp(
  /<meta\s+name="title"\s+content="([^"]*)\">/
);
var YOUTUBE_VIDEOID_REGEX = new RegExp(
  /<link\s+rel="canonical"\s+href="([^"]*)\">/
);
function decodeHtmlEntities(text) {
  return text.replace(/&amp;/g, "&").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&#39;/g, "'").replace(/&apos;/g, "'").replace(
    /&#(\d+);/g,
    (_, code) => String.fromCharCode(parseInt(code, 10))
  ).replace(
    /&#x([a-fA-F0-9]+);/g,
    (_, code) => String.fromCharCode(parseInt(code, 16))
  ).replace(/\n/g, " ").trim();
}
function parseTranscriptXml(xmlContent) {
  const lines = [];
  const textMatches = xmlContent.matchAll(
    /<text\s+start="([^"]+)"\s+dur="([^"]+)"[^>]*>([\s\S]*?)<\/text>/g
  );
  for (const match of textMatches) {
    const startSeconds = parseFloat(match[1]);
    const durationSeconds = parseFloat(match[2]);
    const text = decodeHtmlEntities(match[3].replace(/<[^>]+>/g, ""));
    if (text) {
      lines.push({
        text,
        offset: Math.round(startSeconds * 1e3),
        duration: Math.round(durationSeconds * 1e3)
      });
    }
  }
  if (lines.length === 0) {
    const pMatches = xmlContent.matchAll(
      /<p\s+t="(\d+)"\s+d="(\d+)"[^>]*>([\s\S]*?)<\/p>/g
    );
    for (const match of pMatches) {
      const offset = parseInt(match[1], 10);
      const duration = parseInt(match[2], 10);
      const text = decodeHtmlEntities(match[3].replace(/<[^>]+>/g, ""));
      if (text) {
        lines.push({
          text,
          offset,
          duration
        });
      }
    }
  }
  return lines;
}

// src/youtube-transcript.ts
var _YoutubeTranscript = class _YoutubeTranscript {
  static async getTranscript(url, config) {
    var _a, _b, _c, _d, _e, _f;
    try {
      const videoId = this.extractVideoIdFromUrl(url);
      if (!videoId) {
        throw new YoutubeTranscriptError(
          new Error(
            "Invalid YouTube URL - could not extract video ID"
          )
        );
      }
      console.log(`\u{1F3AC} Fetching transcript for video: ${videoId}`);
      const playerData = await this.fetchPlayerData(videoId, config);
      const title = ((_a = playerData.videoDetails) == null ? void 0 : _a.title) || "Unknown";
      const captionsData = (_b = playerData.captions) == null ? void 0 : _b.playerCaptionsTracklistRenderer;
      if (!captionsData || !captionsData.captionTracks) {
        throw new YoutubeTranscriptError(
          new Error("No captions available for this video")
        );
      }
      console.log(
        `\u{1F4DD} Found ${captionsData.captionTracks.length} caption track(s)`
      );
      const langCode = (config == null ? void 0 : config.lang) || "en";
      const captionTrack = this.findCaptionTrack(
        captionsData.captionTracks,
        langCode
      );
      if (!captionTrack) {
        const availableLangs = captionsData.captionTracks.map((t) => t.languageCode).join(", ");
        throw new YoutubeTranscriptError(
          new Error(
            `No transcript found for language '${langCode}'. Available: ${availableLangs}`
          )
        );
      }
      const trackName = ((_e = (_d = (_c = captionTrack.name) == null ? void 0 : _c.runs) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) || ((_f = captionTrack.name) == null ? void 0 : _f.simpleText) || captionTrack.languageCode;
      console.log(
        `\u{1F504} Using caption track: ${trackName} (${captionTrack.languageCode})`
      );
      const transcriptUrl = captionTrack.baseUrl;
      console.log(
        `\u{1F4E5} Fetching transcript from: ${transcriptUrl.substring(0, 80)}...`
      );
      const lines = await this.fetchTranscriptFromUrl(transcriptUrl);
      console.log(
        `\u2705 Successfully fetched ${lines.length} transcript lines`
      );
      return {
        title: this.decodeHTML(title),
        lines
      };
    } catch (err) {
      if (err instanceof YoutubeTranscriptError) {
        throw err;
      }
      throw new YoutubeTranscriptError(err);
    }
  }
  /**
   * Extract video ID from various YouTube URL formats
   */
  static extractVideoIdFromUrl(url) {
    const patterns = [
      /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/|youtube\.com\/v\/)([a-zA-Z0-9_-]{11})/,
      /^([a-zA-Z0-9_-]{11})$/
      // Just the video ID
    ];
    for (const pattern of patterns) {
      const match = url.match(pattern);
      if (match) {
        return match[1];
      }
    }
    return null;
  }
  /**
   * Fetches player data from YouTube's InnerTube API using ANDROID client
   */
  static async fetchPlayerData(videoId, config) {
    const context = {
      ..._YoutubeTranscript.INNERTUBE_CONTEXT,
      client: {
        ..._YoutubeTranscript.INNERTUBE_CONTEXT.client,
        hl: (config == null ? void 0 : config.lang) || "en",
        gl: (config == null ? void 0 : config.country) || "US"
      }
    };
    const requestBody = {
      context,
      videoId
    };
    console.log(`\u{1F504} Calling InnerTube Player API with ANDROID client...`);
    const response = await (0, import_obsidian.requestUrl)({
      url: _YoutubeTranscript.INNERTUBE_PLAYER_URL,
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "User-Agent": "com.google.android.youtube/19.09.37 (Linux; U; Android 11) gzip"
      },
      body: JSON.stringify(requestBody)
    });
    const data = JSON.parse(response.text);
    const playabilityStatus = data.playabilityStatus;
    if (playabilityStatus) {
      console.log(`\u{1F4CA} Playability status: ${playabilityStatus.status}`);
      if (playabilityStatus.status === "ERROR") {
        throw new Error(
          playabilityStatus.reason || "Video unavailable"
        );
      }
      if (playabilityStatus.status === "LOGIN_REQUIRED") {
        throw new Error("This video requires login to view");
      }
      if (playabilityStatus.status === "UNPLAYABLE") {
        throw new Error(
          playabilityStatus.reason || "Video is unplayable"
        );
      }
    }
    return data;
  }
  /**
   * Finds the best matching caption track for the requested language
   */
  static findCaptionTrack(captionTracks, langCode) {
    let track = captionTracks.find((t) => t.languageCode === langCode);
    if (track) return track;
    track = captionTracks.find(
      (t) => t.languageCode.startsWith(langCode + "-")
    );
    if (track) return track;
    track = captionTracks.find(
      (t) => langCode.startsWith(t.languageCode + "-")
    );
    if (track) return track;
    if (captionTracks.length > 0) {
      console.log(
        `\u26A0\uFE0F Language '${langCode}' not found, falling back to '${captionTracks[0].languageCode}'`
      );
      return captionTracks[0];
    }
    return null;
  }
  /**
   * Fetches transcript XML from the caption track URL
   */
  static async fetchTranscriptFromUrl(transcriptUrl) {
    const response = await (0, import_obsidian.requestUrl)({
      url: transcriptUrl,
      method: "GET",
      headers: {
        "Accept-Language": "en-US,en;q=0.9"
      }
    });
    console.log(
      `\u{1F4C4} Transcript response length: ${response.text.length} bytes`
    );
    if (response.text.length === 0) {
      throw new Error("Received empty transcript response");
    }
    return parseTranscriptXml(response.text);
  }
  /**
   * Decodes HTML entities in a text string
   */
  static decodeHTML(text) {
    return text.replace(/&#39;/g, "'").replace(/&amp;/g, "&").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(
      /&#(\d+);/g,
      (_, code) => String.fromCharCode(parseInt(code, 10))
    ).replace(/\\n/g, " ").replace(/\s+/g, " ").trim();
  }
};
// YouTube's public InnerTube API key
_YoutubeTranscript.INNERTUBE_API_KEY = "AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8";
_YoutubeTranscript.INNERTUBE_PLAYER_URL = `https://www.youtube.com/youtubei/v1/player?key=${_YoutubeTranscript.INNERTUBE_API_KEY}`;
// Use ANDROID client like youtube-transcript-api does - it's less restricted
_YoutubeTranscript.INNERTUBE_CONTEXT = {
  client: {
    clientName: "ANDROID",
    clientVersion: "19.09.37",
    androidSdkVersion: 30,
    hl: "en",
    gl: "US"
  }
};
var YoutubeTranscript = _YoutubeTranscript;

// src/timestampt-utils.ts
var formatTimestamp = (t) => {
  if (t < 0) return "00:00";
  const fnum = (n) => `${n | 0}`.padStart(2, "0");
  const s = 1e3;
  const m = 60 * s;
  const h = 60 * m;
  const hours = Math.floor(t / h);
  const minutes = Math.floor((t - hours * h) / m);
  const seconds = Math.floor((t - hours * h - minutes * m) / s);
  const time = hours ? [hours, minutes, seconds] : [minutes, seconds];
  return time.map(fnum).join(":");
};

// src/render-utils.ts
var highlightText = (div, searchValue) => {
  const content = div.innerHTML;
  const highlightedContent = content.replace(
    new RegExp(searchValue, "gi"),
    '<span class="yt-transcript__highlight">$&</span>'
  );
  div.innerHTML = highlightedContent;
};
var getTranscriptBlocks = (data, timestampMod) => {
  const transcriptBlocks = [];
  let quote = "";
  let quoteTimeOffset = 0;
  data.forEach((line, i) => {
    if (i === 0) {
      quoteTimeOffset = line.offset;
      quote += line.text + " ";
      return;
    }
    if (i % timestampMod == 0) {
      transcriptBlocks.push({
        quote,
        quoteTimeOffset
      });
      quote = "";
      quoteTimeOffset = line.offset;
    }
    quote += line.text + " ";
  });
  if (quote !== "") {
    transcriptBlocks.push({
      quote,
      quoteTimeOffset
    });
  }
  return transcriptBlocks;
};

// src/transcript-view.ts
var TRANSCRIPT_TYPE_VIEW = "transcript-view";
var TranscriptView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.videoData = [];
    this.plugin = plugin;
    this.isDataLoaded = false;
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h4", { text: "Transcript" });
  }
  async onClose() {
    const leafIndex = this.getLeafIndex();
    this.plugin.settings.leafUrls.splice(leafIndex, 1);
  }
  /**
   * Gets the leaf index out of all of the open leaves
   * This assumes that the leaf order shouldn't changed, which is a fair assumption
   */
  getLeafIndex() {
    const leaves = this.app.workspace.getLeavesOfType(TRANSCRIPT_TYPE_VIEW);
    return leaves.findIndex((leaf) => leaf === this.leaf);
  }
  /**
   * Adds a div with loading text to the view content
   */
  renderLoader() {
    if (this.loaderContainerEl !== void 0) {
      this.loaderContainerEl.createEl("div", {
        text: "Loading..."
      });
    }
  }
  /**
   * Adds a text input to the view content
   */
  renderSearchInput(url, data, timestampMod) {
    const searchInputEl = this.contentEl.createEl("input");
    searchInputEl.type = "text";
    searchInputEl.placeholder = "Search...";
    searchInputEl.style.marginBottom = "20px";
    searchInputEl.addEventListener("input", (e) => {
      const searchFilter = e.target.value;
      this.renderTranscriptionBlocks(
        url,
        data,
        timestampMod,
        searchFilter
      );
    });
  }
  /**
   * Adds a div with the video title to the view content
   * @param title - the title of the video
   */
  renderVideoTitle(title) {
    const titleEl = this.contentEl.createEl("div");
    titleEl.innerHTML = title;
    titleEl.style.fontWeight = "bold";
    titleEl.style.marginBottom = "20px";
  }
  formatContentToPaste(url, blocks) {
    return blocks.map((block) => {
      const { quote, quoteTimeOffset } = block;
      const href = url + "&t=" + Math.floor(quoteTimeOffset / 1e3);
      const formattedBlock = `[${formatTimestamp(
        quoteTimeOffset
      )}](${href}) ${quote}`;
      return formattedBlock;
    }).join("\n");
  }
  /**
   * Add a transcription blocks to the view content
   * @param url - the url of the video
   * @param data - the transcript data
   * @param timestampMod - the number of seconds between each timestamp
   * @param searchValue - the value to search for in the transcript
   */
  renderTranscriptionBlocks(url, data, timestampMod, searchValue) {
    const dataContainerEl = this.dataContainerEl;
    if (dataContainerEl !== void 0) {
      dataContainerEl.empty();
      const transcriptBlocks = getTranscriptBlocks(
        data.lines,
        timestampMod
      );
      const filteredBlocks = transcriptBlocks.filter(
        (block) => block.quote.toLowerCase().includes(searchValue.toLowerCase())
      );
      filteredBlocks.forEach((block) => {
        const { quote, quoteTimeOffset } = block;
        const blockContainerEl = createEl("div", {
          cls: "yt-transcript__transcript-block"
        });
        blockContainerEl.draggable = true;
        const linkEl = createEl("a", {
          text: formatTimestamp(quoteTimeOffset),
          attr: {
            href: url + "&t=" + Math.floor(quoteTimeOffset / 1e3)
          }
        });
        linkEl.style.marginBottom = "5px";
        const span = dataContainerEl.createEl("span", {
          text: quote,
          title: "Click to copy"
        });
        span.addEventListener("click", (event) => {
          var _a;
          const target = event.target;
          if (target !== null) {
            navigator.clipboard.writeText((_a = target.textContent) != null ? _a : "");
          }
        });
        if (searchValue !== "") highlightText(span, searchValue);
        blockContainerEl.appendChild(linkEl);
        blockContainerEl.appendChild(span);
        blockContainerEl.addEventListener(
          "dragstart",
          (event) => {
            var _a;
            (_a = event.dataTransfer) == null ? void 0 : _a.setData(
              "text/html",
              blockContainerEl.innerHTML
            );
          }
        );
        blockContainerEl.addEventListener(
          "contextmenu",
          (event) => {
            const menu = new import_obsidian2.Menu();
            menu.addItem(
              (item) => item.setTitle("Copy all").onClick(() => {
                navigator.clipboard.writeText(
                  this.formatContentToPaste(
                    url,
                    filteredBlocks
                  )
                );
              })
            );
            menu.showAtPosition({
              x: event.clientX,
              y: event.clientY
            });
          }
        );
        dataContainerEl.appendChild(blockContainerEl);
      });
    }
  }
  /**
   * Sets the state of the view
   * This is called when the view is loaded
   */
  async setEphemeralState(state) {
    var _a;
    if (this.isDataLoaded) return;
    const leafIndex = this.getLeafIndex();
    if (state.url) {
      this.plugin.settings.leafUrls[leafIndex] = state.url;
      await this.plugin.saveSettings();
    }
    const { lang, country, timestampMod, leafUrls } = this.plugin.settings;
    const url = leafUrls[leafIndex];
    try {
      if (this.loaderContainerEl === void 0) {
        this.loaderContainerEl = this.contentEl.createEl("div");
      } else {
        this.loaderContainerEl.empty();
      }
      this.renderLoader();
      const data = await YoutubeTranscript.getTranscript(url, {
        lang,
        country
      });
      if (!data) throw Error();
      this.isDataLoaded = true;
      this.loaderContainerEl.empty();
      this.renderVideoTitle(data.title);
      this.renderSearchInput(url, data, timestampMod);
      if (this.dataContainerEl === void 0) {
        this.dataContainerEl = this.contentEl.createEl("div");
      } else {
        this.dataContainerEl.empty();
      }
      if (this.errorContainerEl !== void 0) {
        this.errorContainerEl.empty();
      }
      if (data.lines.length === 0) {
        this.dataContainerEl.createEl("h4", {
          text: "No transcript found"
        });
        this.dataContainerEl.createEl("div", {
          text: "Please check if video contains any transcript or try adjust language and country in plugin settings."
        });
      } else {
        this.renderTranscriptionBlocks(url, data, timestampMod, "");
      }
    } catch (err) {
      let errorMessage = "";
      if (err instanceof YoutubeTranscriptError) {
        errorMessage = err.message;
      }
      (_a = this.loaderContainerEl) == null ? void 0 : _a.empty();
      if (this.errorContainerEl === void 0) {
        this.errorContainerEl = this.contentEl.createEl("h5");
      } else {
        this.errorContainerEl.empty();
      }
      const titleEl = this.errorContainerEl.createEl("div", {
        text: "Error loading transcript"
      });
      titleEl.style.marginBottom = "5px";
      const messageEl = this.errorContainerEl.createEl("div", {
        text: errorMessage
      });
      messageEl.style.color = "var(--text-muted)";
      messageEl.style.fontSize = "var(--font-ui-small)";
    }
  }
  getViewType() {
    return TRANSCRIPT_TYPE_VIEW;
  }
  getDisplayText() {
    return "YouTube Transcript";
  }
  getIcon() {
    return "scroll";
  }
};

// src/prompt-modal.ts
var import_obsidian3 = require("obsidian");
var PromptModal = class extends import_obsidian3.Modal {
  constructor(initialValue) {
    super(app);
    this.submitted = false;
    this.initialValue = initialValue;
    this.value = initialValue || "";
  }
  listenInput(evt) {
    if (evt.key === "Enter") {
      evt.preventDefault();
      this.enterCallback(evt);
    }
  }
  onOpen() {
    this.titleEl.setText("YouTube URL");
    this.createForm();
  }
  onClose() {
    this.contentEl.empty();
    if (!this.submitted) {
      this.reject();
    }
  }
  createForm() {
    const textInput = new import_obsidian3.TextComponent(this.contentEl);
    textInput.inputEl.style.width = "100%";
    textInput.onChange((value) => this.value = value);
    textInput.inputEl.addEventListener(
      "keydown",
      (evt) => this.enterCallback(evt)
    );
    if (this.initialValue) {
      textInput.setValue(this.initialValue);
      textInput.inputEl.select();
    }
    textInput.inputEl.focus();
    const buttonDiv = this.modalEl.createDiv();
    buttonDiv.addClass("modal-button-container");
    const submitButton = new import_obsidian3.ButtonComponent(buttonDiv);
    submitButton.buttonEl.addClass("mod-cta");
    submitButton.setButtonText("Submit").onClick((evt) => {
      this.resolveAndClose(evt);
    });
  }
  enterCallback(evt) {
    if (evt.key === "Enter") {
      this.resolveAndClose(evt);
    }
  }
  resolveAndClose(evt) {
    this.submitted = true;
    evt.preventDefault();
    this.resolve(this.value);
    this.close();
  }
  async openAndGetValue(resolve, reject) {
    this.resolve = resolve;
    this.reject = reject;
    this.open();
  }
};

// src/url-utils.ts
var UrlPattern = /(https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|www\.[a-zA-Z0-9][a-zA-Z0-9-]+[a-zA-Z0-9]\.[^\s]{2,}|https?:\/\/(?:www\.|(?!www))[a-zA-Z0-9]+\.[^\s]{2,}|www\.[a-zA-Z0-9]+\.[^\s]{2,})/gi;
function _getLinkNearestCursor(textLine, cursorPosition, linksInLine) {
  if (cursorPosition > textLine.length)
    throw new Error("Cursor out of the line");
  if (!linksInLine || linksInLine.length < 1)
    throw new Error("No links found");
  for (let i = 0; i < linksInLine.length; i++) {
    const link = linksInLine[i];
    const index = linksInLine.length > i + 1 ? textLine.indexOf(linksInLine[i + 1]) : textLine.length;
    if (cursorPosition <= index) return link;
  }
  throw new Error("Unexpected");
}
function getUrlFromText(lineText, cursorPosition) {
  var _a;
  const url = _getLinkNearestCursor(
    lineText,
    cursorPosition,
    (_a = lineText.match(UrlPattern)) != null ? _a : []
  );
  return [lineText.indexOf(url), lineText.indexOf(url) + url.length];
}

// editor-extensions.ts
var EditorExtensions = class {
  static getSelectedText(editor) {
    if (!editor.somethingSelected()) {
      const wordBoundaries = this.getWordBoundaries(editor);
      editor.setSelection(wordBoundaries[0], wordBoundaries[1]);
    }
    return editor.getSelection();
  }
  static getWordBoundaries(editor) {
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const urlPosition = getUrlFromText(lineText, cursor.ch);
    return [
      { line: cursor.line, ch: urlPosition[0] },
      { line: cursor.line, ch: urlPosition[1] }
    ];
  }
};

// src/url-detection.ts
var URLDetector = class {
  /**
   * Checks if the provided URL is a valid YouTube URL
   * @param url - The URL to validate
   * @returns true if the URL is a valid YouTube URL, false otherwise
   */
  static isValidYouTubeUrl(url) {
    if (!url || typeof url !== "string") {
      return false;
    }
    try {
      const urlObj = new URL(url);
      const hostname = urlObj.hostname.toLowerCase();
      const isYouTubeDomain = this.YOUTUBE_DOMAINS.includes(hostname);
      if (!isYouTubeDomain) {
        return false;
      }
      if (hostname.includes("youtube.com")) {
        return urlObj.pathname === "/watch" && urlObj.searchParams.has("v");
      }
      if (hostname.includes("youtu.be")) {
        const pathParts = urlObj.pathname.split("/");
        return pathParts.length >= 2 && pathParts[1].length > 0;
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  /**
   * Extracts the first valid YouTube URL found in the provided text
   * @param text - The text to search for YouTube URLs
   * @returns The first valid YouTube URL found, or null if none found
   */
  static extractYouTubeUrlFromText(text) {
    if (!text || typeof text !== "string") {
      return null;
    }
    const urlRegex = /https?:\/\/[^\s<>"{}|\\^`[\]]+/gi;
    const matches = text.match(urlRegex);
    if (!matches) {
      return null;
    }
    for (const match of matches) {
      if (this.isValidYouTubeUrl(match)) {
        return match;
      }
    }
    return null;
  }
  /**
   * Creates a YouTube URL with a timestamp parameter
   * @param url - The base YouTube URL
   * @param offsetMs - The timestamp offset in milliseconds
   * @returns The URL with timestamp parameter added
   */
  static buildTimestampUrl(url, offsetMs) {
    if (!url || typeof url !== "string") {
      return "";
    }
    try {
      const urlObj = new URL(url);
      const seconds = Math.max(0, Math.floor(offsetMs / 1e3));
      urlObj.searchParams.set("t", seconds.toString());
      return urlObj.toString();
    } catch (error) {
      return url;
    }
  }
};
// YouTube URL patterns to match various formats
URLDetector.YOUTUBE_URL_PATTERNS = [
  /https?:\/\/(?:www\.)?youtube\.com\/watch\?v=[\w-]+(?:[&?][\w=&-]*)?/gi,
  /https?:\/\/(?:www\.)?youtu\.be\/[\w-]+(?:[?][\w=&-]*)?/gi,
  /https?:\/\/(?:m\.)?youtube\.com\/watch\?v=[\w-]+(?:[&?][\w=&-]*)?/gi,
  /https?:\/\/(?:mobile\.)?youtube\.com\/watch\?v=[\w-]+(?:[&?][\w=&-]*)?/gi,
  /https?:\/\/(?:music\.)?youtube\.com\/watch\?v=[\w-]+(?:[&?][\w=&-]*)?/gi
];
// More comprehensive regex for matching YouTube URLs
URLDetector.YOUTUBE_DOMAINS = [
  "youtube.com",
  "www.youtube.com",
  "m.youtube.com",
  "mobile.youtube.com",
  "music.youtube.com",
  "youtu.be",
  "www.youtu.be"
];

// src/transcript-formatter.ts
var TranscriptFormatter = class {
  /**
   * Formats a transcript response according to the specified template and options
   * @param transcript - The transcript response to format
   * @param url - The source YouTube URL
   * @param options - Formatting options including template and timestamp frequency
   * @returns The formatted transcript string
   */
  static format(transcript, url, options) {
    if (!transcript || !transcript.lines || !Array.isArray(transcript.lines)) {
      return "";
    }
    if (transcript.lines.length === 0) {
      return "";
    }
    const normalizedOptions = this.normalizeOptions(options);
    const template = normalizedOptions.template || "standard" /* STANDARD */;
    switch (template) {
      case "minimal" /* MINIMAL */:
        return this.formatMinimalTemplate(
          transcript,
          url,
          normalizedOptions
        );
      case "standard" /* STANDARD */:
        return this.formatStandardTemplate(
          transcript,
          url,
          normalizedOptions
        );
      case "rich" /* RICH */:
        return this.formatRichTemplate(
          transcript,
          url,
          normalizedOptions
        );
      default:
        return this.formatStandardTemplate(
          transcript,
          url,
          normalizedOptions
        );
    }
  }
  /**
   * Convenience method to format transcript with minimal template
   */
  static formatMinimal(transcript, url, options) {
    return this.format(transcript, url, {
      ...options,
      template: "minimal" /* MINIMAL */
    });
  }
  /**
   * Convenience method to format transcript with standard template
   */
  static formatStandard(transcript, url, options) {
    return this.format(transcript, url, {
      ...options,
      template: "standard" /* STANDARD */
    });
  }
  /**
   * Convenience method to format transcript with rich template
   */
  static formatRich(transcript, url, options) {
    return this.format(transcript, url, {
      ...options,
      template: "rich" /* RICH */
    });
  }
  /**
   * Normalizes and validates formatting options
   */
  static normalizeOptions(options) {
    const normalized = {
      timestampMod: Math.max(1, Math.floor(options.timestampMod)) || 5,
      template: options.template || "standard" /* STANDARD */
    };
    if (options.timestampMod <= 0) {
      normalized.timestampMod = 1;
    }
    return normalized;
  }
  /**
   * Formats transcript as plain text without timestamps
   */
  static formatMinimalTemplate(transcript, url, options) {
    return transcript.lines.map((line) => line.text.trim()).filter((text) => text.length > 0).join(" ");
  }
  /**
   * Formats transcript with clickable timestamps
   */
  static formatStandardTemplate(transcript, url, options) {
    const blocks = getTranscriptBlocks(
      transcript.lines,
      options.timestampMod
    );
    if (blocks.length === 0) {
      return "";
    }
    return blocks.map((block) => {
      const { quote, quoteTimeOffset } = block;
      const timestampStr = formatTimestamp(quoteTimeOffset);
      const timestampUrl = url ? URLDetector.buildTimestampUrl(url, quoteTimeOffset) : "#";
      return `[${timestampStr}](${timestampUrl}) ${quote.trim()}`;
    }).join("\n");
  }
  /**
   * Formats transcript with metadata header and clickable timestamps
   */
  static formatRichTemplate(transcript, url, options) {
    const title = transcript.title && transcript.title.trim() ? transcript.title.trim() : "YouTube Transcript";
    const today = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
    const sourceUrl = url || "Unknown";
    const header = [
      `## ${title}`,
      `**Source**: ${sourceUrl}`,
      `**Retrieved**: ${today}`,
      ""
      // Empty line before transcript
    ].join("\n");
    const standardContent = this.formatStandardTemplate(
      transcript,
      url,
      options
    );
    return header + standardContent;
  }
};

// src/commands/insert-transcript.ts
var InsertTranscriptCommand = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Executes the insert transcript command with default settings
   */
  async execute(editor) {
    await this.executeWithOptions(editor, {});
  }
  /**
   * Executes the insert transcript command with custom options
   */
  async executeWithOptions(editor, options) {
    try {
      const url = await this.getYouTubeUrlWithConfirmation(editor);
      if (!url) {
        return;
      }
      if (!URLDetector.isValidYouTubeUrl(url)) {
        return;
      }
      const transcriptConfig = this.createTranscriptConfig();
      const transcript = await YoutubeTranscript.getTranscript(
        url,
        transcriptConfig
      );
      if (!transcript || !transcript.lines || transcript.lines.length === 0) {
        return;
      }
      const formatOptions = this.mergeFormatOptions(options);
      const formattedContent = TranscriptFormatter.format(
        transcript,
        url,
        formatOptions
      );
      if (!formattedContent || formattedContent.trim().length === 0) {
        return;
      }
      const cursor = editor.getCursor();
      editor.replaceRange(formattedContent, cursor);
    } catch (error) {
      console.error("Insert transcript failed:", error);
    }
  }
  /**
   * Gets YouTube URL with user confirmation via prompt
   * Always shows prompt, but pre-populates with detected URL
   */
  async getYouTubeUrlWithConfirmation(editor) {
    const detectedUrl = await this.detectYouTubeUrl(editor);
    try {
      const prompt = new PromptModal(detectedUrl || void 0);
      const userUrl = await new Promise((resolve, reject) => {
        prompt.openAndGetValue(resolve, reject);
      });
      return userUrl.trim() || null;
    } catch (error) {
      return null;
    }
  }
  /**
   * Detects YouTube URL from selection or clipboard (for pre-populating prompt)
   */
  async detectYouTubeUrl(editor) {
    const selectionUrl = this.getUrlFromSelection(editor);
    if (selectionUrl) {
      return selectionUrl;
    }
    const clipboardUrl = await this.getUrlFromClipboard();
    if (clipboardUrl) {
      return clipboardUrl;
    }
    return null;
  }
  /**
   * Gets URL from current editor selection
   */
  getUrlFromSelection(editor) {
    try {
      const selectedText = editor.somethingSelected() ? editor.getSelection() : EditorExtensions.getSelectedText(editor);
      return URLDetector.extractYouTubeUrlFromText(selectedText);
    } catch (error) {
      return null;
    }
  }
  /**
   * Gets URL from system clipboard
   */
  async getUrlFromClipboard() {
    try {
      const clipboardText = await navigator.clipboard.readText();
      return URLDetector.extractYouTubeUrlFromText(clipboardText);
    } catch (error) {
      return null;
    }
  }
  /**
   * Creates transcript config from plugin settings
   */
  createTranscriptConfig() {
    var _a, _b;
    return {
      lang: (_a = this.plugin.settings) == null ? void 0 : _a.lang,
      country: (_b = this.plugin.settings) == null ? void 0 : _b.country
    };
  }
  /**
   * Merges user options with plugin settings
   */
  mergeFormatOptions(options) {
    var _a;
    return {
      template: options.template || "standard" /* STANDARD */,
      timestampMod: options.timestampMod || ((_a = this.plugin.settings) == null ? void 0 : _a.timestampMod) || 5
    };
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  timestampMod: 5,
  lang: "en",
  country: "EN",
  leafUrls: []
};
var YTranscriptPlugin = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.insertTranscriptCommand = new InsertTranscriptCommand(this);
    this.registerView(
      TRANSCRIPT_TYPE_VIEW,
      (leaf) => new TranscriptView(leaf, this)
    );
    this.addCommand({
      id: "transcript-from-text",
      name: "Get YouTube transcript from selected url",
      editorCallback: (editor, _) => {
        const url = EditorExtensions.getSelectedText(editor).trim();
        this.openView(url);
      }
    });
    this.addCommand({
      id: "transcript-from-prompt",
      name: "Get YouTube transcript from url prompt",
      callback: async () => {
        const prompt = new PromptModal();
        const url = await new Promise(
          (resolve) => prompt.openAndGetValue(resolve, () => {
          })
        );
        if (url) {
          this.openView(url);
        }
      }
    });
    this.addCommand({
      id: "insert-youtube-transcript",
      name: "Insert YouTube transcript",
      editorCallback: async (editor, _) => {
        await this.insertTranscriptCommand.execute(editor);
      }
    });
    this.addSettingTab(new YTranslateSettingTab(this.app, this));
  }
  async openView(url) {
    const leaf = this.app.workspace.getRightLeaf(false);
    await leaf.setViewState({
      type: TRANSCRIPT_TYPE_VIEW
    });
    this.app.workspace.revealLeaf(leaf);
    leaf.setEphemeralState({
      url
    });
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(TRANSCRIPT_TYPE_VIEW);
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
var YTranslateSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for YTranscript" });
    new import_obsidian4.Setting(containerEl).setName("Timestamp interval").setDesc(
      "Indicates how often timestamp should occur in text (1 - every line, 10 - every 10 lines)"
    ).addText(
      (text) => text.setValue(this.plugin.settings.timestampMod.toFixed()).onChange(async (value) => {
        const v = Number.parseInt(value);
        this.plugin.settings.timestampMod = Number.isNaN(v) ? 5 : v;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Language").setDesc("Preferred transcript language").addText(
      (text) => text.setValue(this.plugin.settings.lang).onChange(async (value) => {
        this.plugin.settings.lang = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian4.Setting(containerEl).setName("Country").setDesc("Preferred transcript country code").addText(
      (text) => text.setValue(this.plugin.settings.country).onChange(async (value) => {
        this.plugin.settings.country = value;
        await this.plugin.saveSettings();
      })
    );
  }
};

/* nosourcemap */